<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scratch .sb3 Analyzer ‚Äî Ph√¢n t√≠ch logic d·ª± √°n Scratch</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    .drop-zone.dragover { border-color: #22c55e; background: #f0fdf4; }
    .substeps { margin-left: 1.5rem; border-left: 2px solid #e5e7eb; padding-left: 1rem; margin-top: 0.25rem; margin-bottom: 0.25rem; }
    .substeps-else { margin-left: 1.5rem; border-left: 2px solid #fbbf24; padding-left: 1rem; margin-top: 0.25rem; margin-bottom: 0.25rem; }
    .step { padding: 2px 0; line-height: 1.6; }
    .step-num { color: #6b7280; font-size: 0.85em; margin-right: 4px; font-family: monospace; }
    .keyword { color: #7c3aed; font-weight: 600; }
    .value-text { color: #059669; }
    .var-text { color: #dc2626; font-style: italic; }
    .cond-text { color: #2563eb; }
    .event-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.85em; font-weight: 600; margin-bottom: 4px; }
    .event-flag { background: #22c55e; color: white; }
    .event-key { background: #f59e0b; color: white; }
    .event-click { background: #8b5cf6; color: white; }
    .event-broadcast { background: #3b82f6; color: white; }
    .event-clone { background: #ec4899; color: white; }
    .event-other { background: #6b7280; color: white; }
    .event-custom { background: #14b8a6; color: white; }
    .collapsible-header { cursor: pointer; user-select: none; }
    .collapsible-header:hover { background: #f3f4f6; }
    .level-btn { transition: all 0.2s; }
    .level-btn.active { box-shadow: 0 0 0 2px #3b82f6; }
    .severity-red { background: #fef2f2; border-left: 4px solid #ef4444; }
    .severity-yellow { background: #fffbeb; border-left: 4px solid #f59e0b; }
    .severity-green { background: #f0fdf4; border-left: 4px solid #22c55e; }
    .behavior-chip { display: inline-block; padding: 2px 10px; border-radius: 999px; font-size: 0.8em; margin: 2px; background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; }
    .role-badge { display: inline-block; padding: 2px 10px; border-radius: 6px; font-size: 0.8em; font-weight: 600; }
    .role-player { background: #dbeafe; color: #1d4ed8; }
    .role-enemy { background: #fee2e2; color: #b91c1c; }
    .role-projectile { background: #fef3c7; color: #92400e; }
    .role-ui { background: #e0e7ff; color: #4338ca; }
    .role-collectible { background: #d1fae5; color: #065f46; }
    .role-controller { background: #f3e8ff; color: #7c3aed; }
    .role-decoration { background: #f1f5f9; color: #64748b; }
    .role-entity { background: #ecfdf5; color: #047857; }
    .focus-badge { background: #fef3c7; color: #92400e; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; }
    .opcode { display: inline; background: #1e293b; color: #67e8f9; padding: 1px 5px; border-radius: 3px; font-size: 0.78em; font-family: 'SF Mono', 'Fira Code', monospace; letter-spacing: -0.3px; vertical-align: middle; white-space: nowrap; }
    .confidence-high { color: #16a34a; }
    .confidence-mid { color: #d97706; }
    .confidence-low { color: #dc2626; }
    .dev-sprite-header { background: #1e293b; color: #f1f5f9; }
    .dev-script-border { border-left: 4px solid #6366f1; }
    .unresolved { background: #fef2f2; color: #dc2626; padding: 1px 5px; border-radius: 3px; font-size: 0.82em; font-family: 'SF Mono', 'Fira Code', monospace; border: 1px dashed #fca5a5; }
    @media print { .no-print { display: none !important; } }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <!-- Header -->
  <div class="bg-white border-b shadow-sm">
    <div class="max-w-5xl mx-auto px-4 py-4">
      <h1 class="text-2xl font-bold text-gray-800 flex items-center gap-2">üîç Scratch .sb3 Analyzer</h1>
      <p class="text-gray-500 text-sm mt-1">Ph√¢n t√≠ch v√† di·ªÖn gi·∫£i logic d·ª± √°n Scratch ‚Äî d√†nh cho ng∆∞·ªùi kh√¥ng bi·∫øt l·∫≠p tr√¨nh</p>
    </div>
  </div>

  <div class="max-w-5xl mx-auto px-4 py-6">
    <!-- Upload Zone -->
    <div id="dropZone" class="drop-zone no-print border-2 border-dashed border-gray-300 rounded-xl p-10 text-center cursor-pointer transition-all hover:border-green-400 hover:bg-green-50 bg-white">
      <div class="text-5xl mb-3">üìÇ</div>
      <p class="text-lg font-semibold text-gray-700">K√©o th·∫£ file .sb3 v√†o ƒë√¢y</p>
      <p class="text-gray-400 text-sm mt-1">ho·∫∑c nh·∫•p ƒë·ªÉ ch·ªçn file</p>
      <input type="file" id="fileInput" accept=".sb3" class="hidden">
    </div>

    <!-- Loading -->
    <div id="loading" class="hidden text-center py-8">
      <div class="inline-block animate-spin text-4xl">‚öôÔ∏è</div>
      <p class="text-gray-500 mt-2">ƒêang ph√¢n t√≠ch d·ª± √°n...</p>
    </div>

    <!-- Error -->
    <div id="errorBox" class="hidden bg-red-50 border border-red-200 rounded-xl p-4 mt-4">
      <p class="text-red-700 font-semibold">‚ùå L·ªói</p>
      <p id="errorMsg" class="text-red-600 text-sm mt-1"></p>
    </div>

    <!-- Results -->
    <div id="results" class="hidden mt-6 space-y-4">
      <!-- Toolbar -->
      <div class="no-print bg-white rounded-xl border p-4 shadow-sm">
        <div class="flex flex-wrap items-center justify-between gap-3">
          <!-- Level buttons -->
          <div class="flex gap-2">
            <button onclick="switchLevel(1)" id="lvl1" class="level-btn px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-gray-50 hover:bg-gray-100">1Ô∏è‚É£ C∆° b·∫£n</button>
            <button onclick="switchLevel(2)" id="lvl2" class="level-btn px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-blue-50 text-blue-700 active">2Ô∏è‚É£ Trung b√¨nh</button>
            <button onclick="switchLevel(3)" id="lvl3" class="level-btn px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-gray-50 hover:bg-gray-100">3Ô∏è‚É£ N√¢ng cao</button>
          </div>
          <!-- Controls -->
          <div class="flex gap-2 items-center flex-wrap">
            <select id="spriteFocus" onchange="applyFocus()" class="text-sm border rounded-lg px-2 py-1.5 bg-white cursor-pointer">
              <option value="">üìã T·∫•t c·∫£ sprite</option>
            </select>
            <button onclick="showDebugOnly()" class="px-3 py-1.5 bg-amber-50 text-amber-700 rounded-lg text-sm font-medium border border-amber-200 hover:bg-amber-100 cursor-pointer">üêõ Debug</button>
            <button onclick="togglePanel('roles')" id="btnToggleRoles" class="px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-green-50 text-green-700 border-green-200 hover:bg-green-100">üëÅÔ∏è Vai tr√≤</button>
            <button onclick="togglePanel('debug')" id="btnToggleDebug" class="px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-orange-50 text-orange-700 border-orange-200 hover:bg-orange-100">üëÅÔ∏è C·∫£nh b√°o</button>
            <button onclick="copyResults()" class="px-3 py-1.5 bg-blue-500 text-white rounded-lg text-sm font-medium hover:bg-blue-600 cursor-pointer">üìã Copy</button>
            <button onclick="resetTool()" class="px-3 py-1.5 bg-gray-200 text-gray-700 rounded-lg text-sm font-medium hover:bg-gray-300 cursor-pointer">üîÑ File kh√°c</button>
          </div>
        </div>
        <div class="mt-2 text-xs text-gray-400" id="levelDesc">üìä Hi·ªÉn th·ªã logic ch√≠nh, c·∫£nh b√°o th·ª±c t·∫ø, v√† g·ª£i √Ω c·∫£i thi·ªán.</div>
      </div>

      <!-- Dynamic content -->
      <div id="resultsContent"></div>

      <!-- Adjustment section -->
      <div class="no-print bg-white rounded-xl border p-4 shadow-sm" id="adjustmentSection">
        <h3 class="text-sm font-bold text-gray-600 mb-2">üéõÔ∏è ƒêi·ªÅu ch·ªânh m·ª©c ph√¢n t√≠ch</h3>
        <div class="flex gap-2 flex-wrap">
          <button onclick="adjustLevel('less')" class="px-3 py-1.5 bg-gray-100 rounded-lg text-sm hover:bg-gray-200 cursor-pointer">üìù T√≥m g·ªçn h∆°n</button>
          <button onclick="adjustLevel('more')" class="px-3 py-1.5 bg-gray-100 rounded-lg text-sm hover:bg-gray-200 cursor-pointer">üîç Chi ti·∫øt h∆°n</button>
          <button onclick="showDebugOnly()" class="px-3 py-1.5 bg-gray-100 rounded-lg text-sm hover:bg-gray-200 cursor-pointer">üêõ Ch·ªâ xem Debug</button>
          <button onclick="showRecsOnly()" class="px-3 py-1.5 bg-gray-100 rounded-lg text-sm hover:bg-gray-200 cursor-pointer">üí° Ch·ªâ xem G·ª£i √Ω</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <div class="max-w-5xl mx-auto px-4 py-6 text-center text-xs text-gray-400 border-t mt-8">
    <p>Scratch .sb3 Analyzer ‚Äî Ph√¢n t√≠ch file Scratch 3.0 tr·ª±c ti·∫øp trong tr√¨nh duy·ªát. Kh√¥ng upload l√™n server.</p>
  </div>

  <!-- Toast -->
  <div id="toast" class="fixed bottom-6 right-6 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg transition-opacity duration-300 opacity-0 pointer-events-none text-sm">ƒê√£ copy!</div>

<script>
// ========================================================================
// GLOBALS
// ========================================================================
let globalAnalysisData = null;
let currentLevel = 2;
let currentFocus = '';
let debugOnlyMode = false;
let showOpcodes = false;
let showRolesPanel = true;
let showDebugPanel = true;

// ========================================================================
// UTILITY
// ========================================================================
function esc(str) {
  return String(str == null ? '' : str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}
function kw(s) { return `<span class="keyword">${s}</span>`; }
function val(s) { return `<span class="value-text">${esc(s)}</span>`; }
function varRef(s) { return `<span class="var-text">${esc(s)}</span>`; }
function cond(s) { return `<span class="cond-text">${s}</span>`; }

// ========================================================================
// FILE HANDLING
// ========================================================================
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('dragover'); if (e.dataTransfer.files.length) processFile(e.dataTransfer.files[0]); });
fileInput.addEventListener('change', e => { if (e.target.files.length) processFile(e.target.files[0]); });

async function processFile(file) {
  if (!file.name.endsWith('.sb3')) { showError('Vui l√≤ng ch·ªçn file c√≥ ƒëu√¥i .sb3'); return; }
  hideError();
  document.getElementById('results').classList.add('hidden');
  document.getElementById('loading').classList.remove('hidden');
  try {
    const zip = await JSZip.loadAsync(file);
    const projectFile = zip.file('project.json');
    if (!projectFile) throw new Error('Kh√¥ng t√¨m th·∫•y project.json trong file .sb3.');
    const text = await projectFile.async('string');
    const project = JSON.parse(text);
    globalAnalysisData = analyzeProject(project, file.name);
    currentLevel = 2;
    currentFocus = '';
    debugOnlyMode = false;
    showRolesPanel = true;
    showDebugPanel = true;
    const _rBtn = document.getElementById('btnToggleRoles');
    const _dBtn = document.getElementById('btnToggleDebug');
    if (_rBtn) { _rBtn.innerHTML = 'üëÅÔ∏è Vai tr√≤'; _rBtn.className = 'px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-green-50 text-green-700 border-green-200 hover:bg-green-100'; }
    if (_dBtn) { _dBtn.innerHTML = 'üëÅÔ∏è C·∫£nh b√°o'; _dBtn.className = 'px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-orange-50 text-orange-700 border-orange-200 hover:bg-orange-100'; }
    populateSpriteFocus();
    renderResults();
    document.getElementById('results').classList.remove('hidden');
  } catch (err) {
    showError(err.message || 'Kh√¥ng th·ªÉ ƒë·ªçc file .sb3');
  } finally {
    document.getElementById('loading').classList.add('hidden');
  }
}

function showError(msg) { document.getElementById('errorMsg').textContent = msg; document.getElementById('errorBox').classList.remove('hidden'); }
function hideError() { document.getElementById('errorBox').classList.add('hidden'); }
function resetTool() { document.getElementById('results').classList.add('hidden'); fileInput.value = ''; globalAnalysisData = null; }

// ========================================================================
// INPUT RESOLUTION
// ========================================================================
function resolveInput(name, block, blocks, depth) {
  if (depth > 40) return '(‚Ä¶)';
  if (!block.inputs || !block.inputs[name]) {
    return '<span class="unresolved">[UNRESOLVED INPUT: "' + esc(name) + '" kh√¥ng t·ªìn t·∫°i trong block ' + esc(block.opcode || '?') + ']</span>';
  }
  const input = block.inputs[name];
  const st = input[0];
  if (st === 1) {
    if (input[1] === null || input[1] === undefined) return '(tr·ªëng)';
    if (Array.isArray(input[1])) return resolveLiteral(input[1]);
    if (typeof input[1] === 'string' && blocks[input[1]]) return describeReporterOrMenu(input[1], blocks, depth + 1);
    if (typeof input[1] === 'string') return '<span class="unresolved">[UNRESOLVED BLOCK ID: ' + esc(input[1].substring(0,20)) + ']</span>';
    return esc(String(input[1]));
  }
  if (st === 2) {
    if (input[1] === null || input[1] === undefined) return '(tr·ªëng)';
    // Check for literal array first (variable/list refs can appear in any state)
    if (Array.isArray(input[1])) return resolveLiteral(input[1]);
    if (typeof input[1] === 'string' && blocks[input[1]]) return describeReporterOrMenu(input[1], blocks, depth + 1);
    if (typeof input[1] === 'string') return '<span class="unresolved">[UNRESOLVED BLOCK ID: ' + esc(input[1].substring(0,20)) + ']</span>';
    return '<span class="unresolved">[UNRESOLVED INPUT type=2]</span>';
  }
  if (st === 3) {
    // Priority 1: input[1] is a reporter block ID (string that exists in blocks)
    if (input[1] !== null && typeof input[1] === 'string' && blocks[input[1]]) return describeReporterOrMenu(input[1], blocks, depth + 1);
    // Priority 2: input[1] is a literal variable/list/value array e.g. [12, "varName", "varId"]
    if (input[1] !== null && Array.isArray(input[1])) return resolveLiteral(input[1]);
    // Priority 3: Fall to shadow/default value in input[2]
    if (input[2] !== null && input[2] !== undefined) {
      if (Array.isArray(input[2])) return resolveLiteral(input[2]);
      if (typeof input[2] === 'string' && blocks[input[2]]) return describeReporterOrMenu(input[2], blocks, depth + 1);
    }
    const rid = (input[1] && typeof input[1] === 'string') ? input[1].substring(0,20) : String(input[1]);
    return '<span class="unresolved">[UNRESOLVED VARIABLE ID: ' + esc(rid) + ']</span>';
  }
  return '<span class="unresolved">[UNRESOLVED INPUT state=' + st + ']</span>';
}

function resolveLiteral(arr) {
  if (!Array.isArray(arr) || arr.length < 2) return '<span class="unresolved">[UNRESOLVED LITERAL: d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá]</span>';
  const t = arr[0], v = arr[1];
  if (v === null || v === undefined) return '(tr·ªëng)';
  switch (t) {
    case 4: case 5: case 6: case 7: case 8: return val(v);
    case 9: return `<span style="display:inline-block;width:14px;height:14px;background:${esc(v)};border:1px solid #999;border-radius:3px;vertical-align:middle;"></span> ${val(v)}`;
    case 10: return v === '' ? '(chu·ªói r·ªóng)' : `"${val(v)}"`;
    case 11: return `"${val(v)}"`;
    case 12: return varRef('bi·∫øn ¬´' + v + '¬ª');
    case 13: return varRef('danh s√°ch ¬´' + v + '¬ª');
    default: return val(v);
  }
}

function resolveField(name, block) {
  if (!block.fields || !block.fields[name]) return '[UNRESOLVED FIELD: ' + name + ']';
  return block.fields[name][0];
}

function describeReporterOrMenu(blockId, blocks, depth) {
  const block = blocks[blockId];
  if (!block) return '<span class="unresolved">[UNRESOLVED BLOCK ID: ' + esc(String(blockId).substring(0,20)) + ']</span>';
  if (block.shadow) { const f = block.fields; if (f) { for (const k in f) return esc(f[k][0]); } return '<span class="unresolved">[UNRESOLVED SHADOW: kh√¥ng c√≥ fields]</span>'; }
  return describeReporter(blockId, blocks, depth);
}

// ========================================================================
// REPORTER DESCRIPTION
// ========================================================================
function describeReporter(blockId, blocks, depth) {
  if (depth > 40) return '(‚Ä¶)';
  const block = blocks[blockId];
  if (!block) return '???';
  const ri = (n) => resolveInput(n, block, blocks, depth + 1);
  const rf = (n) => resolveField(n, block);
  const op = block.opcode;
  if (block.shadow) { const f = block.fields; if (f) { for (const k in f) return esc(f[k][0]); } }

  switch (op) {
    case 'operator_add': return `(${ri('NUM1')} + ${ri('NUM2')})`;
    case 'operator_subtract': return `(${ri('NUM1')} - ${ri('NUM2')})`;
    case 'operator_multiply': return `(${ri('NUM1')} √ó ${ri('NUM2')})`;
    case 'operator_divide': return `(${ri('NUM1')} √∑ ${ri('NUM2')})`;
    case 'operator_random': return `s·ªë ng·∫´u nhi√™n t·ª´ ${ri('FROM')} ƒë·∫øn ${ri('TO')}`;
    case 'operator_gt': return cond(ri('OPERAND1') + ' &gt; ' + ri('OPERAND2'));
    case 'operator_lt': return cond(ri('OPERAND1') + ' &lt; ' + ri('OPERAND2'));
    case 'operator_equals': return cond(ri('OPERAND1') + ' = ' + ri('OPERAND2'));
    case 'operator_and': return cond('(' + ri('OPERAND1') + ') v√† (' + ri('OPERAND2') + ')');
    case 'operator_or': return cond('(' + ri('OPERAND1') + ') ho·∫∑c (' + ri('OPERAND2') + ')');
    case 'operator_not': return cond('kh√¥ng ph·∫£i (' + ri('OPERAND') + ')');
    case 'operator_join': return `n·ªëi ${ri('STRING1')} v·ªõi ${ri('STRING2')}`;
    case 'operator_letter_of': return `k√Ω t·ª± th·ª© ${ri('LETTER')} c·ªßa ${ri('STRING')}`;
    case 'operator_length': return `ƒë·ªô d√†i c·ªßa ${ri('STRING')}`;
    case 'operator_contains': return cond(ri('STRING1') + ' c√≥ ch·ª©a ' + ri('STRING2') + '?');
    case 'operator_mod': return `(${ri('NUM1')} chia l·∫•y d∆∞ ${ri('NUM2')})`;
    case 'operator_round': return `l√†m tr√≤n(${ri('NUM')})`;
    case 'operator_mathop': {
      const fn = rf('OPERATOR');
      const m = {'abs':'tr·ªã tuy·ªát ƒë·ªëi','floor':'l√†m tr√≤n xu·ªëng','ceiling':'l√†m tr√≤n l√™n','sqrt':'cƒÉn b·∫≠c hai','sin':'sin','cos':'cos','tan':'tan','asin':'arcsin','acos':'arccos','atan':'arctan','ln':'ln','log':'log','e ^':'e m≈©','10 ^':'10 m≈©'};
      return `${m[fn]||fn}(${ri('NUM')})`;
    }
    case 'sensing_touchingobject': return cond('ƒëang ch·∫°m ' + ri('TOUCHINGOBJECTMENU') + '?');
    case 'sensing_touchingcolor': return cond('ƒëang ch·∫°m m√†u ' + ri('COLOR') + '?');
    case 'sensing_coloristouchingcolor': return cond('m√†u ' + ri('COLOR') + ' ch·∫°m m√†u ' + ri('COLOR2') + '?');
    case 'sensing_distanceto': return `kho·∫£ng c√°ch ƒë·∫øn ${ri('DISTANCETOMENU')}`;
    case 'sensing_answer': return 'c√¢u tr·∫£ l·ªùi';
    case 'sensing_keypressed': return cond('ph√≠m ' + ri('KEY_OPTION') + ' ƒëang nh·∫•n?');
    case 'sensing_mousedown': return cond('chu·ªôt ƒëang nh·∫•n?');
    case 'sensing_mousex': return 't·ªça ƒë·ªô x chu·ªôt';
    case 'sensing_mousey': return 't·ªça ƒë·ªô y chu·ªôt';
    case 'sensing_loudness': return 'ƒë·ªô ·ªìn';
    case 'sensing_timer': return 'ƒë·ªìng h·ªì ƒë·∫øm';
    case 'sensing_of': {
      const prop = rf('PROPERTY');
      const pm = {'x position':'t·ªça ƒë·ªô x','y position':'t·ªça ƒë·ªô y','direction':'h∆∞·ªõng','costume #':'s·ªë trang ph·ª•c','costume name':'t√™n trang ph·ª•c','backdrop #':'s·ªë ph√¥ng n·ªÅn','backdrop name':'t√™n ph√¥ng n·ªÅn','size':'k√≠ch th∆∞·ªõc','volume':'√¢m l∆∞·ª£ng'};
      return `${pm[prop]||prop} c·ªßa ${ri('OBJECT')}`;
    }
    case 'sensing_current': {
      const m = rf('CURRENTMENU');
      const cm = {'YEAR':'nƒÉm','MONTH':'th√°ng','DATE':'ng√†y','DAYOFWEEK':'th·ª©','HOUR':'gi·ªù','MINUTE':'ph√∫t','SECOND':'gi√¢y'};
      return `${cm[m]||m} hi·ªán t·∫°i`;
    }
    case 'sensing_dayssince2000': return 's·ªë ng√†y t·ª´ nƒÉm 2000';
    case 'sensing_username': return 't√™n ng∆∞·ªùi d√πng';
    case 'motion_xposition': return 't·ªça ƒë·ªô x';
    case 'motion_yposition': return 't·ªça ƒë·ªô y';
    case 'motion_direction': return 'h∆∞·ªõng';
    case 'looks_costumenumbername': return rf('NUMBER_NAME') === 'number' ? 's·ªë trang ph·ª•c' : 't√™n trang ph·ª•c';
    case 'looks_backdropnumbername': return rf('NUMBER_NAME') === 'number' ? 's·ªë ph√¥ng n·ªÅn' : 't√™n ph√¥ng n·ªÅn';
    case 'looks_size': return 'k√≠ch th∆∞·ªõc';
    case 'sound_volume': return '√¢m l∆∞·ª£ng';
    case 'data_variable': return varRef('bi·∫øn ¬´' + rf('VARIABLE') + '¬ª');
    case 'data_listcontents': return varRef('danh s√°ch ¬´' + rf('LIST') + '¬ª');
    case 'data_itemoflist': return `ph·∫ßn t·ª≠ ${ri('INDEX')} c·ªßa ${varRef('danh s√°ch ¬´' + rf('LIST') + '¬ª')}`;
    case 'data_itemnumoflist': return `v·ªã tr√≠ ${ri('ITEM')} trong ${varRef('danh s√°ch ¬´' + rf('LIST') + '¬ª')}`;
    case 'data_lengthoflist': return `s·ªë ph·∫ßn t·ª≠ ${varRef('danh s√°ch ¬´' + rf('LIST') + '¬ª')}`;
    case 'data_listcontainsitem': return cond(varRef('danh s√°ch ¬´' + rf('LIST') + '¬ª') + ' ch·ª©a ' + ri('ITEM') + '?');
    case 'argument_reporter_string_number': return `[tham s·ªë "${esc(rf('VALUE'))}"]`;
    case 'argument_reporter_boolean': return `[tham s·ªë logic "${esc(rf('VALUE'))}"]`;
    case 'music_getTempo': return 'tempo';
    default: return `‚ü®${esc(op)}‚ü©`;
  }
}

// ========================================================================
// BLOCK DESCRIPTION (for Advanced mode detailed view)
// ========================================================================
function describeBlock(blockId, blocks, prefix, depth) {
  if (depth > 40) return `<div class="step"><span class="step-num">${prefix}.</span> (‚Ä¶qu√° s√¢u‚Ä¶)</div>`;
  const block = blocks[blockId];
  if (!block || !block.opcode) return '';
  const ri = (n) => resolveInput(n, block, blocks, depth);
  const rf = (n) => resolveField(n, block);
  const op = block.opcode;

  const renderSubstack = (inputName) => {
    const inp = block.inputs && block.inputs[inputName];
    const cls = inputName === 'SUBSTACK2' ? 'substeps-else' : 'substeps';
    if (!inp || inp[1] === null || inp[1] === undefined) return `<div class="${cls}"><div class="step text-gray-400 italic">(kh√¥ng c√≥ h√†nh ƒë·ªông)</div></div>`;
    const firstId = typeof inp[1] === 'string' ? inp[1] : null;
    if (!firstId) return `<div class="${cls}"><div class="step text-gray-400 italic">(kh√¥ng c√≥ h√†nh ƒë·ªông)</div></div>`;
    return `<div class="${cls}">${followChain(firstId, blocks, prefix, depth + 1)}</div>`;
  };

  const SIMPLE = {
    'motion_ifonedgebounce': 'N·∫øu ch·∫°m c·∫°nh, b·∫≠t l·∫°i',
    'looks_nextcostume': 'Chuy·ªÉn trang ph·ª•c ti·∫øp theo',
    'looks_nextbackdrop': 'Chuy·ªÉn ph√¥ng n·ªÅn ti·∫øp theo',
    'looks_cleargraphiceffects': 'X√≥a hi·ªáu ·ª©ng ƒë·ªì h·ªça',
    'looks_show': 'Hi·ªán sprite',
    'looks_hide': '·∫®n sprite',
    'sound_stopallsounds': 'D·ª´ng t·∫•t c·∫£ √¢m thanh',
    'sound_cleareffects': 'X√≥a hi·ªáu ·ª©ng √¢m thanh',
    'control_delete_this_clone': 'X√≥a b·∫£n sao n√†y',
    'sensing_resettimer': 'ƒê·∫∑t l·∫°i ƒë·ªìng h·ªì ƒë·∫øm',
    'pen_clear': 'X√≥a v·∫øt v·∫Ω',
    'pen_stamp': 'ƒê√≥ng d·∫•u sprite',
    'pen_penDown': 'H·∫° b√∫t (b·∫Øt ƒë·∫ßu v·∫Ω)',
    'pen_penUp': 'Nh·∫•c b√∫t (ng·ª´ng v·∫Ω)',
  };
  const opcodeTag = showOpcodes ? `<code class="opcode">[${esc(op)}]</code> ` : '';
  if (SIMPLE[op]) return `<div class="step"><span class="step-num">${prefix}.</span> ${opcodeTag}${SIMPLE[op]}</div>`;

  let html = '';
  const step = (t) => `<div class="step"><span class="step-num">${prefix}.</span> ${opcodeTag}${t}</div>`;

  switch (op) {
    case 'motion_movesteps': return step(`Di chuy·ªÉn ${ri('STEPS')} b∆∞·ªõc`);
    case 'motion_turnright': return step(`Xoay ph·∫£i ${ri('DEGREES')}¬∞`);
    case 'motion_turnleft': return step(`Xoay tr√°i ${ri('DEGREES')}¬∞`);
    case 'motion_goto': return step(`ƒêi ƒë·∫øn ${ri('TO')}`);
    case 'motion_gotoxy': return step(`ƒêi ƒë·∫øn x=${ri('X')}, y=${ri('Y')}`);
    case 'motion_glideto': return step(`Tr∆∞·ª£t ƒë·∫øn ${ri('TO')} trong ${ri('SECS')}s`);
    case 'motion_glidesecs': return step(`Tr∆∞·ª£t ƒë·∫øn x=${ri('X')}, y=${ri('Y')} trong ${ri('SECS')}s`);
    case 'motion_pointindirection': return step(`ƒê·∫∑t h∆∞·ªõng = ${ri('DIRECTION')}¬∞`);
    case 'motion_pointtowards': return step(`Quay v·ªÅ ph√≠a ${ri('TOWARDS')}`);
    case 'motion_changexby': return step(`Thay ƒë·ªïi x th√™m ${ri('DX')}`);
    case 'motion_setx': return step(`ƒê·∫∑t x = ${ri('X')}`);
    case 'motion_changeyby': return step(`Thay ƒë·ªïi y th√™m ${ri('DY')}`);
    case 'motion_sety': return step(`ƒê·∫∑t y = ${ri('Y')}`);
    case 'motion_setrotationstyle': return step(`Ki·ªÉu xoay: "${esc(rf('STYLE'))}"`);
    case 'looks_sayforsecs': return step(`N√≥i "${ri('MESSAGE')}" trong ${ri('SECS')}s`);
    case 'looks_say': return step(`N√≥i "${ri('MESSAGE')}"`);
    case 'looks_thinkforsecs': return step(`Nghƒ© "${ri('MESSAGE')}" trong ${ri('SECS')}s`);
    case 'looks_think': return step(`Nghƒ© "${ri('MESSAGE')}"`);
    case 'looks_switchcostumeto': return step(`ƒê·ªïi trang ph·ª•c: ${ri('COSTUME')}`);
    case 'looks_switchbackdropto': return step(`ƒê·ªïi ph√¥ng n·ªÅn: ${ri('BACKDROP')}`);
    case 'looks_changesizeby': return step(`Thay ƒë·ªïi k√≠ch th∆∞·ªõc th√™m ${ri('CHANGE')}%`);
    case 'looks_setsizeto': return step(`ƒê·∫∑t k√≠ch th∆∞·ªõc = ${ri('SIZE')}%`);
    case 'looks_changeeffectby': return step(`Thay ƒë·ªïi hi·ªáu ·ª©ng "${esc(rf('EFFECT'))}" th√™m ${ri('CHANGE')}`);
    case 'looks_seteffectto': return step(`ƒê·∫∑t hi·ªáu ·ª©ng "${esc(rf('EFFECT'))}" = ${ri('VALUE')}`);
    case 'looks_gotofrontback': return step(rf('FRONT_BACK') === 'front' ? 'ƒê∆∞a l√™n tr∆∞·ªõc' : 'ƒê∆∞a ra sau');
    case 'looks_goforwardbackwardlayers': return step(`Di chuy·ªÉn ${rf('FORWARD_BACKWARD') === 'forward' ? 'l√™n' : 'xu·ªëng'} ${ri('NUM')} l·ªõp`);
    case 'sound_playuntildone': return step(`Ph√°t ${ri('SOUND_MENU')} (ƒë·ª£i xong)`);
    case 'sound_play': return step(`Ph√°t ${ri('SOUND_MENU')}`);
    case 'sound_changeeffectby': return step(`Thay ƒë·ªïi hi·ªáu ·ª©ng √¢m "${esc(rf('EFFECT'))}" th√™m ${ri('VALUE')}`);
    case 'sound_seteffectto': return step(`ƒê·∫∑t hi·ªáu ·ª©ng √¢m "${esc(rf('EFFECT'))}" = ${ri('VALUE')}`);
    case 'sound_changevolumeby': return step(`Thay ƒë·ªïi √¢m l∆∞·ª£ng th√™m ${ri('VOLUME')}`);
    case 'sound_setvolumeto': return step(`ƒê·∫∑t √¢m l∆∞·ª£ng = ${ri('VOLUME')}%`);
    case 'event_broadcast': return step(`G·ª≠i broadcast "${ri('BROADCAST_INPUT')}"`);
    case 'event_broadcastandwait': return step(`G·ª≠i broadcast "${ri('BROADCAST_INPUT')}" v√† ${kw('ƒë·ª£i')}`);
    case 'control_wait': return step(`${kw('ƒê·ª£i')} ${ri('DURATION')}s`);
    case 'control_forever':
      html = `<div class="step"><span class="step-num">${prefix}.</span> ${opcodeTag}${kw('V√≤ng l·∫∑p v√¥ h·∫°n.')} M·ªói v√≤ng th·ª±c hi·ªán:</div>`;
      html += renderSubstack('SUBSTACK');
      html += `<div class="step text-gray-400 text-xs italic ml-6">‚Üª L·∫∑p l·∫°i m√£i m√£i</div>`;
      return html;
    case 'control_repeat':
      html = `<div class="step"><span class="step-num">${prefix}.</span> ${opcodeTag}${kw('L·∫∑p')} ${ri('TIMES')} ${kw('l·∫ßn:')} </div>`;
      html += renderSubstack('SUBSTACK');
      return html;
    case 'control_repeat_until':
      html = `<div class="step"><span class="step-num">${prefix}.</span> ${opcodeTag}${kw('L·∫∑p cho ƒë·∫øn khi')} ${cond(ri('CONDITION'))}:</div>`;
      html += renderSubstack('SUBSTACK');
      return html;
    case 'control_if':
      html = `<div class="step"><span class="step-num">${prefix}.</span> ${opcodeTag}${kw('N·∫øu')} ${cond(ri('CONDITION'))} ${kw('th√¨:')}</div>`;
      html += renderSubstack('SUBSTACK');
      return html;
    case 'control_if_else':
      html = `<div class="step"><span class="step-num">${prefix}.</span> ${opcodeTag}${kw('N·∫øu')} ${cond(ri('CONDITION'))} ${kw('th√¨:')}</div>`;
      html += renderSubstack('SUBSTACK');
      html += `<div class="step"><span class="step-num"></span> ${kw('Ng∆∞·ª£c l·∫°i:')}</div>`;
      html += renderSubstack('SUBSTACK2');
      return html;
    case 'control_wait_until': return step(`${kw('ƒê·ª£i cho ƒë·∫øn khi')} ${cond(ri('CONDITION'))}`);
    case 'control_stop': {
      const opt = rf('STOP_OPTION');
      const sm = {'all':'t·∫•t c·∫£','this script':'script n√†y','other scripts in sprite':'script kh√°c c·ªßa sprite'};
      return step(`${kw('D·ª´ng')} ${sm[opt]||opt}`);
    }
    case 'control_create_clone_of': return step(`T·∫°o b·∫£n sao c·ªßa ${ri('CLONE_OPTION')}`);
    case 'data_setvariableto': return step(`ƒê·∫∑t ${varRef('¬´' + rf('VARIABLE') + '¬ª')} = ${ri('VALUE')}`);
    case 'data_changevariableby': return step(`Thay ƒë·ªïi ${varRef('¬´' + rf('VARIABLE') + '¬ª')} th√™m ${ri('VALUE')}`);
    case 'data_showvariable': return step(`Hi·ªán bi·∫øn ${varRef('¬´' + rf('VARIABLE') + '¬ª')}`);
    case 'data_hidevariable': return step(`·∫®n bi·∫øn ${varRef('¬´' + rf('VARIABLE') + '¬ª')}`);
    case 'data_addtolist': return step(`Th√™m ${ri('ITEM')} v√†o ${varRef('¬´' + rf('LIST') + '¬ª')}`);
    case 'data_deleteoflist': return step(`X√≥a ph·∫ßn t·ª≠ ${ri('INDEX')} kh·ªèi ${varRef('¬´' + rf('LIST') + '¬ª')}`);
    case 'data_deletealloflist': return step(`X√≥a t·∫•t c·∫£ kh·ªèi ${varRef('¬´' + rf('LIST') + '¬ª')}`);
    case 'data_insertatlist': return step(`Ch√®n ${ri('ITEM')} v√†o v·ªã tr√≠ ${ri('INDEX')} c·ªßa ${varRef('¬´' + rf('LIST') + '¬ª')}`);
    case 'data_replaceitemoflist': return step(`Thay ph·∫ßn t·ª≠ ${ri('INDEX')} trong ${varRef('¬´' + rf('LIST') + '¬ª')} = ${ri('ITEM')}`);
    case 'data_showlist': return step(`Hi·ªán ${varRef('¬´' + rf('LIST') + '¬ª')}`);
    case 'data_hidelist': return step(`·∫®n ${varRef('¬´' + rf('LIST') + '¬ª')}`);
    case 'sensing_askandwait': return step(`H·ªèi "${ri('QUESTION')}" v√† ƒë·ª£i`);
    case 'sensing_setdragmode': return step(`Ch·∫ø ƒë·ªô k√©o: "${rf('DRAG_MODE')}"`);
    case 'pen_setPenColorToColor': return step(`ƒê·∫∑t m√†u b√∫t = ${ri('COLOR')}`);
    case 'pen_changePenColorParamBy': return step(`Thay ƒë·ªïi ${ri('COLOR_PARAM')} b√∫t th√™m ${ri('VALUE')}`);
    case 'pen_setPenColorParamTo': return step(`ƒê·∫∑t ${ri('COLOR_PARAM')} b√∫t = ${ri('VALUE')}`);
    case 'pen_changePenSizeBy': return step(`Thay ƒë·ªïi n√©t b√∫t th√™m ${ri('SIZE')}`);
    case 'pen_setPenSizeTo': return step(`ƒê·∫∑t n√©t b√∫t = ${ri('SIZE')}`);
    case 'procedures_definition': {
      const pi = block.inputs && block.inputs['custom_block'];
      let pn = '???';
      if (pi && typeof pi[1] === 'string' && blocks[pi[1]] && blocks[pi[1]].mutation) pn = blocks[pi[1]].mutation.proccode;
      return step(`${kw('ƒê·ªãnh nghƒ©a kh·ªëi:')} "${esc(pn)}"`);
    }
    case 'procedures_call': {
      const mut = block.mutation;
      if (!mut) return step('G·ªçi kh·ªëi t√πy ch·ªânh');
      const pc = mut.proccode || '???';
      const aids = mut.argumentids ? JSON.parse(mut.argumentids) : [];
      let parts = [], ai = 0, li = 0;
      const rx = /%[sb]/g;
      let m;
      while ((m = rx.exec(pc)) !== null) { if (m.index > li) parts.push(esc(pc.substring(li, m.index))); const aid = aids[ai++]; parts.push(aid && block.inputs && block.inputs[aid] ? resolveInput(aid, block, blocks, depth) : '???'); li = rx.lastIndex; }
      if (li < pc.length) parts.push(esc(pc.substring(li)));
      return step(`G·ªçi: "${parts.join('')}"`);
    }
    case 'procedures_prototype': return '';
    case 'music_playDrumForBeats': return step(`Tr·ªëng ${ri('DRUM')} trong ${ri('BEATS')} nh·ªãp`);
    case 'music_restForBeats': return step(`Ngh·ªâ ${ri('BEATS')} nh·ªãp`);
    case 'music_playNoteForBeats': return step(`N·ªët ${ri('NOTE')} trong ${ri('BEATS')} nh·ªãp`);
    case 'music_setInstrument': return step(`Nh·∫°c c·ª•: ${ri('INSTRUMENT')}`);
    case 'music_setTempo': return step(`Tempo = ${ri('TEMPO')}`);
    case 'music_changeTempo': return step(`Thay ƒë·ªïi tempo th√™m ${ri('TEMPO')}`);
    case 'text2speech_speakAndWait': return step(`ƒê·ªçc "${ri('WORDS')}" v√† ƒë·ª£i`);
    case 'text2speech_setVoice': return step(`Gi·ªçng: ${ri('VOICE')}`);
    case 'text2speech_setLanguage': return step(`Ng√¥n ng·ªØ: ${ri('LANGUAGE')}`);
    default: {
      let id = '';
      if (block.inputs) { const p = []; for (const k in block.inputs) { if (k === 'SUBSTACK' || k === 'SUBSTACK2') continue; p.push(`${k}=${ri(k)}`); } if (p.length) id = ` (${p.join(', ')})`; }
      return step(`<span class="text-gray-500">[${esc(op)}]${id}</span>`);
    }
  }
}

function followChain(startId, blocks, parentPrefix, depth) {
  let html = '', currentId = startId, stepNum = 1;
  while (currentId) {
    const block = blocks[currentId];
    if (!block) break;
    if (block.opcode === 'procedures_prototype') { currentId = block.next; continue; }
    const prefix = parentPrefix ? `${parentPrefix}.${stepNum}` : `${stepNum}`;
    html += describeBlock(currentId, blocks, prefix, depth);
    stepNum++;
    currentId = block.next;
  }
  return html;
}

// ========================================================================
// HAT BLOCKS & EVENTS
// ========================================================================
const HAT_OPCODES = new Set([
  'event_whenflagclicked','event_whenkeypressed','event_whenthisspriteclicked',
  'event_whenstageclicked','event_whenbackdropswitchesto','event_whengreaterthan',
  'event_whenbroadcastreceived','control_start_as_clone','procedures_definition',
  'videoSensing_whenMotionGreaterThan','makeymakey_whenMakeyKeyPressed','makeymakey_whenCodePressed'
]);

function findHatBlocks(blocks) {
  const hats = [];
  for (const id in blocks) {
    const b = blocks[id];
    if (!b || typeof b !== 'object' || Array.isArray(b)) continue;
    if (!b.topLevel || !b.opcode) continue;
    if (HAT_OPCODES.has(b.opcode)) hats.push(id);
  }
  return hats;
}

function getEventDescription(block, blocks) {
  const rf = (n) => resolveField(n, block);
  const ri = (n) => resolveInput(n, block, blocks, 0);
  switch (block.opcode) {
    case 'event_whenflagclicked': return { text: 'üü¢ Khi nh·∫•n c·ªù xanh', cls: 'event-flag' };
    case 'event_whenkeypressed': return { text: `‚å®Ô∏è Khi nh·∫•n ph√≠m "${esc(rf('KEY_OPTION'))}"`, cls: 'event-key' };
    case 'event_whenthisspriteclicked': return { text: 'üñ±Ô∏è Khi sprite ƒë∆∞·ª£c nh·∫•p', cls: 'event-click' };
    case 'event_whenstageclicked': return { text: 'üñ±Ô∏è Khi Stage ƒë∆∞·ª£c nh·∫•p', cls: 'event-click' };
    case 'event_whenbackdropswitchesto': return { text: `üé≠ Khi ph√¥ng n·ªÅn ‚Üí "${esc(rf('BACKDROP'))}"`, cls: 'event-other' };
    case 'event_whengreaterthan': {
      const m = rf('WHENGREATERTHANMENU');
      return { text: `üìä Khi ${m==='LOUDNESS'?'ƒë·ªô ·ªìn':'ƒë·ªìng h·ªì'} > ${ri('VALUE')}`, cls: 'event-other' };
    }
    case 'event_whenbroadcastreceived': return { text: `üì® Khi nh·∫≠n "${esc(rf('BROADCAST_OPTION'))}"`, cls: 'event-broadcast' };
    case 'control_start_as_clone': return { text: 'üêë Khi b·∫£n sao ƒë∆∞·ª£c t·∫°o', cls: 'event-clone' };
    case 'procedures_definition': {
      const pi = block.inputs && block.inputs['custom_block'];
      let pn = '???';
      if (pi && typeof pi[1] === 'string' && blocks[pi[1]] && blocks[pi[1]].mutation) pn = blocks[pi[1]].mutation.proccode;
      return { text: `üß© Kh·ªëi: "${esc(pn)}"`, cls: 'event-custom' };
    }
    default: return { text: `‚ñ∂Ô∏è ${esc(block.opcode)}`, cls: 'event-other' };
  }
}

// ========================================================================
// PATTERN SCANNING ‚Äî Qu√©t pattern c·ªßa t·ª´ng chu·ªói block
// ========================================================================
function scanChainPatterns(startId, blocks) {
  const p = {
    hasMotion: false, setsPosition: false, hasGlide: false,
    hasForeverLoop: false, hasRepeatLoop: false, hasConditional: false,
    hasKeyChecks: false, keyNames: new Set(),
    hasCollision: false, collisionTargets: new Set(),
    hasCloning: false, deletesClone: false,
    hasSay: false, hasThink: false, hasAsk: false,
    hasSound: false, hasPen: false,
    hasCostumeChange: false, hasBackdropChange: false, hasEffects: false,
    hasWait: false, hasWaitNoDelay: false,
    broadcastsSent: [], broadcastsReceived: [],
    varsSet: new Set(), varsChanged: new Set(),
    listsModified: new Set(),
    hasRandom: false, hasAnswer: false,
    hasStop: false, stopType: null,
    hasCustomCall: false, customCalls: [],
    hasShow: false, hasHide: false,
    blockCount: 0,
    foreverHasWait: true, // assume true, set false if forever found without wait
  };

  const visited = new Set();
  let insideForever = false;
  let foreverHasWaitBlock = false;

  function scan(id, inForever) {
    if (!id || visited.has(id)) return;
    visited.add(id);
    const b = blocks[id];
    if (!b || !b.opcode) return;
    p.blockCount++;
    const op = b.opcode;

    // Motion
    if (op.startsWith('motion_')) { p.hasMotion = true; }
    if (op === 'motion_gotoxy' || op === 'motion_setx' || op === 'motion_sety' || op === 'motion_goto') p.setsPosition = true;
    if (op === 'motion_glidesecs' || op === 'motion_glideto') p.hasGlide = true;

    // Looks
    if (op === 'looks_switchcostumeto' || op === 'looks_nextcostume') p.hasCostumeChange = true;
    if (op === 'looks_switchbackdropto' || op === 'looks_nextbackdrop') p.hasBackdropChange = true;
    if (op.includes('effect')) p.hasEffects = true;
    if (op === 'looks_say' || op === 'looks_sayforsecs') p.hasSay = true;
    if (op === 'looks_think' || op === 'looks_thinkforsecs') p.hasThink = true;
    if (op === 'looks_show') p.hasShow = true;
    if (op === 'looks_hide') p.hasHide = true;

    // Sound
    if (op.startsWith('sound_') || op.startsWith('music_')) p.hasSound = true;

    // Control
    if (op === 'control_forever') {
      p.hasForeverLoop = true;
      // Check if substack has wait
      foreverHasWaitBlock = false;
      insideForever = true;
    }
    if (op === 'control_repeat' || op === 'control_repeat_until') p.hasRepeatLoop = true;
    if (op === 'control_if' || op === 'control_if_else') p.hasConditional = true;
    if (op === 'control_wait' || op === 'control_wait_until') { p.hasWait = true; if (inForever) foreverHasWaitBlock = true; }
    if (op === 'control_create_clone_of') p.hasCloning = true;
    if (op === 'control_delete_this_clone') p.deletesClone = true;
    if (op === 'control_stop') { p.hasStop = true; p.stopType = resolveField('STOP_OPTION', b); }

    // Data
    if (op === 'data_setvariableto') p.varsSet.add(resolveField('VARIABLE', b));
    if (op === 'data_changevariableby') p.varsChanged.add(resolveField('VARIABLE', b));
    if (op === 'data_addtolist' || op === 'data_deleteoflist' || op === 'data_deletealloflist' || op === 'data_insertatlist' || op === 'data_replaceitemoflist') p.listsModified.add(resolveField('LIST', b));

    // Sensing
    if (op === 'sensing_askandwait') p.hasAsk = true;

    // Events
    if (op === 'event_broadcast' || op === 'event_broadcastandwait') {
      const msg = extractBroadcastName(b, blocks);
      if (msg) p.broadcastsSent.push(msg);
    }

    // Pen
    if (op.startsWith('pen_')) p.hasPen = true;

    // Custom blocks
    if (op === 'procedures_call') {
      p.hasCustomCall = true;
      if (b.mutation && b.mutation.proccode) p.customCalls.push(b.mutation.proccode);
    }

    // Scan reporter inputs for sensing patterns
    if (b.inputs) {
      for (const key in b.inputs) {
        const inp = b.inputs[key];
        if (inp && typeof inp[1] === 'string' && blocks[inp[1]]) scanReporter(inp[1], blocks, p);
        if (inp && inp[0] === 3 && typeof inp[1] === 'string' && blocks[inp[1]]) scanReporter(inp[1], blocks, p);
      }
    }

    // Follow substacks
    if (b.inputs) {
      const isForever = op === 'control_forever';
      if (b.inputs.SUBSTACK && b.inputs.SUBSTACK[1] && typeof b.inputs.SUBSTACK[1] === 'string')
        scan(b.inputs.SUBSTACK[1], inForever || isForever);
      if (b.inputs.SUBSTACK2 && b.inputs.SUBSTACK2[1] && typeof b.inputs.SUBSTACK2[1] === 'string')
        scan(b.inputs.SUBSTACK2[1], inForever || isForever);
    }

    if (b.next) scan(b.next, inForever);
  }

  scan(startId, false);
// Post-process: check forever loop wait
if (p.hasForeverLoop && !p.hasWait && !p.hasSay && !p.hasGlide && !p.hasSound) {
p.foreverHasWait = false;
}
return p;
}
function scanReporter(blockId, blocks, patterns) {
const b = blocks[blockId];
if (!b) return;
if (b.opcode === 'sensing_keypressed') {
patterns.hasKeyChecks = true;
const keyInp = b.inputs && b.inputs['KEY_OPTION'];
if (keyInp && keyInp[1] && typeof keyInp[1] === 'string' && blocks[keyInp[1]]) {
const kb = blocks[keyInp[1]];
if (kb && kb.fields && kb.fields['KEY_OPTION']) patterns.keyNames.add(kb.fields['KEY_OPTION'][0]);
}
}
if (b.opcode === 'sensing_touchingobject') {
patterns.hasCollision = true;
const ti = b.inputs && b.inputs['TOUCHINGOBJECTMENU'];
if (ti && ti[1] && typeof ti[1] === 'string' && blocks[ti[1]]) {
const tb = blocks[ti[1]];
if (tb && tb.fields && tb.fields['TOUCHINGOBJECTMENU']) patterns.collisionTargets.add(tb.fields['TOUCHINGOBJECTMENU'][0]);
}
}
if (b.opcode === 'sensing_answer') patterns.hasAnswer = true;
if (b.opcode === 'operator_random') patterns.hasRandom = true;
if (b.opcode === 'sensing_mousedown' || b.opcode === 'sensing_mousex' || b.opcode === 'sensing_mousey') patterns.hasKeyChecks = true;
// Recurse
if (b.inputs) {
for (const k in b.inputs) {
const inp = b.inputs[k];
if (inp && typeof inp[1] === 'string' && blocks[inp[1]]) scanReporter(inp[1], blocks, patterns);
}
}
}
function extractBroadcastName(block, blocks) {
const inp = block.inputs && block.inputs['BROADCAST_INPUT'];
if (!inp) return null;
if (inp[0] === 1 && Array.isArray(inp[1])) return inp[1][1];
if (inp[0] === 3) {
if (inp[1] && typeof inp[1] === 'string' && blocks[inp[1]]) return null;
if (inp[2] && Array.isArray(inp[2])) return inp[2][1];
}
return null;
}
// ========================================================================
// ROLE DETECTION
// ========================================================================
function detectSpriteRole(name, isStage, agg) {
if (isStage) {
const reasons = ['Stage lu√¥n ƒë√≥ng vai tr√≤ qu·∫£n l√Ω n·ªÅn'];
if (agg.broadcastsSent.size > 2) reasons.push('G·ª≠i ' + agg.broadcastsSent.size + ' broadcast ‚Üí ƒëi·ªÅu ph·ªëi nhi·ªÅu sprite');
if (agg.hasBackdropChange) reasons.push('Qu·∫£n l√Ω chuy·ªÉn ph√¥ng n·ªÅn');
if (agg.allVarsSet.size > 0) reasons.push('Kh·ªüi t·∫°o bi·∫øn to√†n c·ª•c');
const conf = (agg.broadcastsSent.size > 2 || agg.hasBackdropChange) ? 90 : 75;
const desc = (agg.broadcastsSent.size > 2 || agg.hasBackdropChange) ? 'ƒêi·ªÅu ph·ªëi game / Qu·∫£n l√Ω c·∫£nh' : 'N·ªÅn v√† qu·∫£n l√Ω chung';
return { role: 'controller', desc, cls: 'role-controller', confidence: conf, reasons };
}
const hasKeys = agg.hasKeyControls;
const isCloned = agg.hasCloneStart;
const doesClone = agg.hasCloning;
const hasCollision = agg.hasCollision;
const hasMotion = agg.hasMotion;
const modifiesScore = [...agg.allVarsChanged].some(v => /score|ƒëi·ªÉm|point/i.test(v));
const modifiesLife = [...agg.allVarsChanged].some(v => /life|m·∫°ng|health|hp/i.test(v));
const nameSuggestsBullet = /bullet|ƒë·∫°n|projectile|shot|arrow|laser|beam|fire|b·∫Øn|t√™n/i.test(name);
const nameSuggestsEnemy = /enemy|ƒë·ªãch|monster|qu√°i|obstacle|ch∆∞·ªõng|boss|zombie|alien|spider|bat/i.test(name);
const nameSuggestsItem = /coin|xu|item|v·∫≠t ph·∫©m|star|sao|gem|heart|tim|collect|power|apple|fruit/i.test(name);
// ===== PLAYER =====
if (hasKeys && hasMotion && !isCloned) {
const reasons = ['ƒêi·ªÅu khi·ªÉn b·∫±ng ph√≠m b·∫•m', 'C√≥ block di chuy·ªÉn', 'Kh√¥ng ph·∫£i b·∫£n sao (clone)'];
let conf = 85;
if (agg.hasForeverLoop) { conf += 5; reasons.push('C√≥ v√≤ng l·∫∑p ch√≠nh ki·ªÉm tra ph√≠m'); }
if (hasCollision) { conf += 3; reasons.push('Ki·ªÉm tra va ch·∫°m v·ªõi ƒë·ªëi t∆∞·ª£ng kh√°c'); }
return { role: 'player', desc: 'Nh√¢n v·∫≠t ch√≠nh (ƒëi·ªÅu khi·ªÉn b·∫±ng ph√≠m)', cls: 'role-player', confidence: Math.min(conf, 95), reasons };
}
// ===== CLONED SPRITES: Scoring-based classification =====
if (isCloned) {
let bulletScore = 0, enemyScore = 0, collectScore = 0, entityScore = 0;
const bulletR = [], enemyR = [], collectR = [], entityR = [];
// Motion
if (hasMotion) { bulletScore += 2; enemyScore += 2; entityScore += 2; }

// Self-deletion pattern
if (agg.deletesClone) {
  bulletScore += 3; bulletR.push('T·ª± x√≥a b·∫£n sao');
  collectScore += 2; collectR.push('T·ª± x√≥a sau t∆∞∆°ng t√°c');
  enemyScore += 1;
}

// Complexity
if (agg.blockCount < 35) {
  bulletScore += 2; bulletR.push('Logic ƒë∆°n gi·∫£n (' + agg.blockCount + ' block)');
} else {
  enemyScore += 2; enemyR.push('Logic ph·ª©c t·∫°p (' + agg.blockCount + ' block)');
}

// Forever loop = movement pattern = more like enemy
if (agg.hasForeverLoop) {
  enemyScore += 3; enemyR.push('C√≥ v√≤ng l·∫∑p di chuy·ªÉn/h√†nh vi');
  entityScore += 2;
} else {
  bulletScore += 2; bulletR.push('Kh√¥ng c√≥ v√≤ng l·∫∑p ph·ª©c t·∫°p');
}

// Collision behavior
if (hasCollision) {
  enemyScore += 2; enemyR.push('Ki·ªÉm tra va ch·∫°m');
  collectScore += 2; collectR.push('Ki·ªÉm tra va ch·∫°m');
  const collidesEdge = [...agg.collisionTargets].some(t => /_edge_/i.test(t));
  if (collidesEdge) { bulletScore += 2; bulletR.push('Ki·ªÉm tra va ch·∫°m c·∫°nh m√†n h√¨nh'); }
} else {
  bulletScore += 1;
}

// Variable modifications
if (modifiesScore && !modifiesLife) {
  collectScore += 3; collectR.push('Thay ƒë·ªïi bi·∫øn ƒëi·ªÉm s·ªë');
  bulletScore += 1;
}
if (modifiesLife) {
  enemyScore += 3; enemyR.push('Thay ƒë·ªïi bi·∫øn m·∫°ng/health');
}

// Name-based hints (strong signals)
if (nameSuggestsBullet) { bulletScore += 4; bulletR.push('T√™n "' + name + '" g·ª£i √Ω ƒë·∫°n/v·∫≠t th·ªÉ b·∫Øn'); }
if (nameSuggestsEnemy) { enemyScore += 4; enemyR.push('T√™n "' + name + '" g·ª£i √Ω k·∫ª ƒë·ªãch'); }
if (nameSuggestsItem) { collectScore += 4; collectR.push('T√™n "' + name + '" g·ª£i √Ω v·∫≠t ph·∫©m'); }

// Negative signals
if (hasKeys) { bulletScore -= 5; enemyScore -= 3; }

const candidates = [
  { role: 'projectile', score: bulletScore, desc: 'ƒê·∫°n / V·∫≠t th·ªÉ b·∫Øn ra', cls: 'role-projectile', reasons: ['ƒê∆∞·ª£c t·∫°o t·ª´ clone', ...bulletR] },
  { role: 'enemy', score: enemyScore, desc: 'K·∫ª ƒë·ªãch / Ch∆∞·ªõng ng·∫°i v·∫≠t', cls: 'role-enemy', reasons: ['ƒê∆∞·ª£c t·∫°o t·ª´ clone', ...enemyR] },
  { role: 'collectible', score: collectScore, desc: 'V·∫≠t ph·∫©m thu th·∫≠p', cls: 'role-collectible', reasons: ['ƒê∆∞·ª£c t·∫°o t·ª´ clone', ...collectR] },
  { role: 'entity', score: entityScore, desc: 'ƒê·ªëi t∆∞·ª£ng clone', cls: 'role-entity', reasons: ['ƒê∆∞·ª£c t·∫°o t·ª´ clone', ...entityR] },
];
candidates.sort((a, b) => b.score - a.score);
const best = candidates[0];
const second = candidates[1];
const gap = best.score - second.score;

let confidence;
if (gap >= 5) confidence = 85;
else if (gap >= 3) confidence = 70;
else if (gap >= 1) confidence = 55;
else confidence = 40;

if (gap <= 2 && second.score > 0) {
  best.reasons.push('‚ö†Ô∏è C≈©ng c√≥ th·ªÉ l√†: ' + second.desc + ' (ch√™nh l·ªách ƒëi·ªÉm: ' + gap + ')');
  if (confidence > 50) confidence = 50;
}
return { role: best.role, desc: best.desc, cls: best.cls, confidence: Math.min(confidence, 95), reasons: best.reasons };}
// ===== NON-CLONED, NON-KEY-CONTROLLED =====
if (doesClone) {
const reasons = ['T·∫°o b·∫£n sao (clone) c·ªßa sprite kh√°c ho·∫∑c ch√≠nh m√¨nh'];
let conf = 70;
if (agg.broadcastsSent.size > 0) { conf += 10; reasons.push('G·ª≠i broadcast ƒëi·ªÅu ph·ªëi'); }
return { role: 'controller', desc: 'Ngu·ªìn t·∫°o b·∫£n sao', cls: 'role-controller', confidence: Math.min(conf, 85), reasons };
}
if (agg.hasClickHandlers && (agg.hasSay || agg.broadcastsSent.size > 0) && !hasMotion) {
const reasons = ['Ph·∫£n h·ªìi click chu·ªôt', 'Kh√¥ng c√≥ di chuy·ªÉn'];
if (agg.hasSay) reasons.push('Hi·ªÉn th·ªã text');
if (agg.broadcastsSent.size > 0) reasons.push('G·ª≠i broadcast khi nh·∫•p');
return { role: 'ui', desc: 'N√∫t b·∫•m / Giao di·ªán', cls: 'role-ui', confidence: 75, reasons };
}
if (hasMotion && hasCollision) {
return { role: 'entity', desc: 'ƒê·ªëi t∆∞·ª£ng t∆∞∆°ng t√°c', cls: 'role-entity', confidence: 60, reasons: ['C√≥ di chuy·ªÉn', 'Ki·ªÉm tra va ch·∫°m', 'Kh√¥ng ƒëi·ªÅu khi·ªÉn b·∫±ng ph√≠m, kh√¥ng ph·∫£i clone'] };
}
if (hasKeys && !hasMotion) {
return { role: 'player', desc: 'Nh√¢n v·∫≠t (ƒëi·ªÅu khi·ªÉn b·∫±ng ph√≠m, kh√¥ng di chuy·ªÉn tr·ª±c ti·∫øp)', cls: 'role-player', confidence: 55, reasons: ['C√≥ ƒëi·ªÅu khi·ªÉn b·∫±ng ph√≠m', 'Kh√¥ng c√≥ block di chuy·ªÉn tr·ª±c ti·∫øp ‚Äî c√≥ th·ªÉ d√πng c√°ch kh√°c'] };
}
if (hasMotion) {
return { role: 'entity', desc: 'ƒê·ªëi t∆∞·ª£ng di chuy·ªÉn', cls: 'role-entity', confidence: 55, reasons: ['C√≥ di chuy·ªÉn', 'Kh√¥ng r√µ vai tr√≤ c·ª• th·ªÉ'] };
}
if (agg.hasSay || agg.hasAsk) {
return { role: 'ui', desc: 'Hi·ªÉn th·ªã th√¥ng tin / H·ªôi tho·∫°i', cls: 'role-ui', confidence: 60, reasons: ['Hi·ªÉn th·ªã text ho·∫∑c h·ªèi ng∆∞·ªùi d√πng'] };
}
if (agg.hasPen) {
return { role: 'entity', desc: 'V·∫Ω b·∫±ng b√∫t', cls: 'role-entity', confidence: 65, reasons: ['S·ª≠ d·ª•ng block b√∫t v·∫Ω'] };
}
return { role: 'decoration', desc: 'Trang tr√≠ / Ph·ª• tr·ª£', cls: 'role-decoration', confidence: 40, reasons: ['Kh√¥ng ph√°t hi·ªán logic t∆∞∆°ng t√°c ƒë√°ng k·ªÉ', 'C√≥ th·ªÉ l√† h√¨nh n·ªÅn, trang tr√≠, ho·∫∑c sprite ch∆∞a ho√†n thi·ªán'] };
}
function detectProjectType(gp) {
if (gp.penBlocks > 5) return { genre: 'art', desc: 'üé® D·ª± √°n v·∫Ω / Ngh·ªá thu·∫≠t' };
if (gp.askBlocks > 3) return { genre: 'quiz', desc: '‚ùì Tr√≤ ch∆°i h·ªèi ƒë√°p / Quiz' };
if (gp.musicBlocks > 5) return { genre: 'music', desc: 'üéµ D·ª± √°n √¢m nh·∫°c' };
if (gp.keyHandlers > 0 && gp.cloneBlocks > 0 && gp.collisionChecks > 0) {
if (gp.gravityLike) return { genre: 'platformer', desc: 'üèÉ Game nh·∫£y (Platformer)' };
return { genre: 'arcade', desc: 'üïπÔ∏è Game Arcade / H√†nh ƒë·ªông' };
}
if (gp.keyHandlers > 0 && gp.collisionChecks > 0) return { genre: 'game', desc: 'üéÆ Tr√≤ ch∆°i t∆∞∆°ng t√°c' };
if (gp.keyHandlers > 0 && gp.motionBlocks > 5) return { genre: 'game', desc: 'üéÆ Tr√≤ ch∆°i ƒëi·ªÅu khi·ªÉn' };
if (gp.backdropSwitches > 2 && gp.broadcastCount > 3) return { genre: 'story', desc: 'üìñ C√¢u chuy·ªán / Ho·∫°t h√¨nh' };
if (gp.backdropSwitches > 0 && gp.sayBlocks > 3) return { genre: 'story', desc: 'üìñ C√¢u chuy·ªán / Tr√¨nh chi·∫øu' };
if (gp.clickHandlers > 3) return { genre: 'clicker', desc: 'üñ±Ô∏è Game nh·∫•p chu·ªôt' };
if (gp.cloneBlocks > 0 && gp.collisionChecks > 0) return { genre: 'arcade', desc: 'üïπÔ∏è Game Arcade' };
if (gp.blockCount > 100 && gp.varCount > 5) return { genre: 'simulation', desc: '‚öôÔ∏è M√¥ ph·ªèng / D·ª± √°n ph·ª©c t·∫°p' };
if (gp.blockCount < 20) return { genre: 'simple', desc: '‚ú® D·ª± √°n ƒë∆°n gi·∫£n / Th·ª≠ nghi·ªám' };
return { genre: 'general', desc: 'üì¶ D·ª± √°n Scratch ƒëa d·ª•ng' };
}
// ========================================================================
// ANALYSIS ENGINE ‚Äî Returns structured data, no rendering
// ========================================================================
function analyzeProject(project, fileName) {
const targets = project.targets || [];
if (!targets.length) { showError('Project kh√¥ng c√≥ targets.'); return null; }
targets.sort((a, b) => a.isStage === b.isStage ? 0 : a.isStage ? -1 : 1);
// Global pattern counters
const gp = {
blockCount: 0, varCount: 0, listCount: 0,
keyHandlers: 0, clickHandlers: 0, cloneBlocks: 0,
collisionChecks: 0, motionBlocks: 0, sayBlocks: 0,
askBlocks: 0, penBlocks: 0, musicBlocks: 0,
backdropSwitches: 0, broadcastCount: 0,
gravityLike: false, costumeCount: 0, soundCount: 0,
};
const allVars = [];
const allLists = [];
const allBroadcastsSent = new Set();
const allBroadcastsReceived = new Set();
const varModifiers = {}; // varName -> [{sprite, event}]
const spritesData = [];
for (const target of targets) {
const blocks = target.blocks || {};
let tBlockCount = 0;
for (const id in blocks) { const b = blocks[id]; if (b && typeof b === 'object' && !Array.isArray(b) && b.opcode) tBlockCount++; }
gp.blockCount += tBlockCount;
gp.costumeCount += (target.costumes || []).length;
gp.soundCount += (target.sounds || []).length;const vars = target.variables || {};
for (const vid in vars) { gp.varCount++; allVars.push({ name: vars[vid][0], value: vars[vid][1], scope: target.isStage ? 'to√†n c·ª•c' : `sprite "${target.name}"`, targetName: target.name }); }
const lists = target.lists || {};
for (const lid in lists) { gp.listCount++; allLists.push({ name: lists[lid][0], items: lists[lid][1], scope: target.isStage ? 'to√†n c·ª•c' : `sprite "${target.name}"`, targetName: target.name }); }

// Scan blocks for global patterns
for (const id in blocks) {
  const b = blocks[id];
  if (!b || !b.opcode) continue;
  const op = b.opcode;
  if (op.startsWith('motion_')) gp.motionBlocks++;
  if (op === 'control_create_clone_of') gp.cloneBlocks++;
  if (op === 'looks_say' || op === 'looks_sayforsecs') gp.sayBlocks++;
  if (op === 'sensing_askandwait') gp.askBlocks++;
  if (op.startsWith('pen_')) gp.penBlocks++;
  if (op.startsWith('music_')) gp.musicBlocks++;
  if (op === 'looks_switchbackdropto' || op === 'looks_nextbackdrop') gp.backdropSwitches++;
  if (op === 'event_whenkeypressed') gp.keyHandlers++;
  if (op === 'event_whenthisspriteclicked' || op === 'event_whenstageclicked') gp.clickHandlers++;
  // Detect gravity-like pattern: changeyby with negative in forever
  if (op === 'motion_changeyby') {
    const yInput = b.inputs && b.inputs['DY'];
    if (yInput && Array.isArray(yInput[1]) && Number(yInput[1][1]) < 0) gp.gravityLike = true;
  }
}

// Find hat blocks
const hats = findHatBlocks(blocks);
const spriteAgg = {
  hasMotion: false, hasKeyControls: false, hasClickHandlers: false,
  hasCollision: false, hasCloning: false, hasCloneStart: false,
  deletesClone: false, hasForeverLoop: false,
  hasSay: false, hasAsk: false, hasPen: false, hasSound: false,
  hasBackdropChange: false, hasCostumeChange: false,
  broadcastsSent: new Set(), broadcastsReceived: new Set(),
  allVarsSet: new Set(), allVarsChanged: new Set(),
  collisionTargets: new Set(), keyNames: new Set(),
  blockCount: tBlockCount,
};

const scriptsData = [];
for (const hatId of hats) {
  const hat = blocks[hatId];
  if (!hat) continue;
  const evDesc = getEventDescription(hat, blocks);
  const chainP = scanChainPatterns(hatId, blocks);

  // Merge chain patterns into sprite aggregate
  if (chainP.hasMotion) spriteAgg.hasMotion = true;
  if (chainP.hasKeyChecks) { spriteAgg.hasKeyControls = true; chainP.keyNames.forEach(k => spriteAgg.keyNames.add(k)); }
  if (chainP.hasCollision) { spriteAgg.hasCollision = true; chainP.collisionTargets.forEach(t => spriteAgg.collisionTargets.add(t)); }
  if (chainP.hasCloning) spriteAgg.hasCloning = true;
  if (hat.opcode === 'control_start_as_clone') spriteAgg.hasCloneStart = true;
  if (chainP.deletesClone) spriteAgg.deletesClone = true;
  if (chainP.hasForeverLoop) spriteAgg.hasForeverLoop = true;
  if (chainP.hasSay || chainP.hasThink) spriteAgg.hasSay = true;
  if (chainP.hasAsk) spriteAgg.hasAsk = true;
  if (chainP.hasPen) spriteAgg.hasPen = true;
  if (chainP.hasSound) spriteAgg.hasSound = true;
  if (chainP.hasBackdropChange) spriteAgg.hasBackdropChange = true;
  if (chainP.hasCostumeChange) spriteAgg.hasCostumeChange = true;
  if (hat.opcode === 'event_whenthisspriteclicked' || hat.opcode === 'event_whenstageclicked') spriteAgg.hasClickHandlers = true;
  chainP.varsSet.forEach(v => spriteAgg.allVarsSet.add(v));
  chainP.varsChanged.forEach(v => spriteAgg.allVarsChanged.add(v));
  chainP.broadcastsSent.forEach(m => { spriteAgg.broadcastsSent.add(m); allBroadcastsSent.add(m); });
  if (hat.opcode === 'event_whenbroadcastreceived') {
    const bn = resolveField('BROADCAST_OPTION', hat);
    if (bn !== '???') { spriteAgg.broadcastsReceived.add(bn); allBroadcastsReceived.add(bn); }
  }

  // Track var modifications for conflict detection
  chainP.varsSet.forEach(v => { if (!varModifiers[v]) varModifiers[v] = []; varModifiers[v].push({ sprite: target.name, event: evDesc.text }); });
  chainP.varsChanged.forEach(v => { if (!varModifiers[v]) varModifiers[v] = []; varModifiers[v].push({ sprite: target.name, event: evDesc.text }); });

  // Pre-render detailed HTML
  let detailedHtml = '';
  if (hat.next) detailedHtml = followChain(hat.next, blocks, '', 0);

  scriptsData.push({
    hatId, eventDesc: evDesc,
    chainPatterns: chainP,
    detailedHtml,
    blockCount: chainP.blockCount,
  });
}

gp.broadcastCount = allBroadcastsSent.size;

// Global collision checks
if (spriteAgg.hasCollision) gp.collisionChecks++;

// Also detect key checks from sensing blocks
if (spriteAgg.hasKeyControls) gp.keyHandlers = Math.max(gp.keyHandlers, 1);

const role = detectSpriteRole(target.name, target.isStage, spriteAgg);

// Generate behavior summary
const behaviors = generateBehaviors(target, spriteAgg, scriptsData);

// Count orphan blocks
    let orphanCount = 0;
    for (const id in blocks) {
      const b = blocks[id];
      if (!b || typeof b !== 'object' || Array.isArray(b) || !b.topLevel || !b.opcode) continue;
      if (HAT_OPCODES.has(b.opcode)) continue;
      if (b.opcode === 'data_variable' || b.opcode === 'data_listcontents') continue;
      if (b.shadow) continue;
      if (!b.parent) orphanCount++;
    }

    spritesData.push({
      name: target.name,
      isStage: target.isStage,
      role,
      scriptCount: hats.length,
      behaviors,
      scripts: scriptsData,
      agg: spriteAgg,
      targetBlocks: blocks,
      costumeCount: (target.costumes || []).length,
      soundCount: (target.sounds || []).length,
      blockCount: tBlockCount,
      orphanCount,
    });
  }

  const projectType = detectProjectType(gp);

  // Generate warnings
  const warnings = generateWarnings(spritesData, allBroadcastsSent, allBroadcastsReceived, varModifiers, gp);

  // Generate recommendations
  const recommendations = generateRecommendations(spritesData, warnings, gp, projectType);

  // Generate TL;DR
  const tldr = generateTLDR(spritesData, projectType, gp, allVars);

  // Generate game flow
  const gameFlow = generateGameFlow(spritesData, allBroadcastsSent, allBroadcastsReceived);

  return {
    fileName, projectType, tldr, gameFlow,
    overview: { spriteCount: targets.filter(t => !t.isStage).length, blockCount: gp.blockCount, varCount: gp.varCount, listCount: gp.listCount, costumeCount: gp.costumeCount, soundCount: gp.soundCount },
    variables: allVars, lists: allLists,
    sprites: spritesData,
    warnings, recommendations,
    globalPatterns: gp,
  };
}

// ========================================================================
// BEHAVIOR SUMMARY GENERATION
// ========================================================================
function generateBehaviors(target, agg, scripts) {
  const b = [];
  if (target.isStage) {
    if (agg.hasBackdropChange) b.push('Qu·∫£n l√Ω chuy·ªÉn c·∫£nh (ph√¥ng n·ªÅn)');
    if (agg.broadcastsSent.size > 0) b.push(`ƒêi·ªÅu ph·ªëi game qua broadcast: ${[...agg.broadcastsSent].slice(0, 3).join(', ')}${agg.broadcastsSent.size > 3 ? '...' : ''}`);
    if (agg.allVarsSet.size > 0) b.push(`Kh·ªüi t·∫°o/qu·∫£n l√Ω bi·∫øn: ${[...agg.allVarsSet].slice(0, 3).join(', ')}${agg.allVarsSet.size > 3 ? '...' : ''}`);
    if (agg.hasSound) b.push('Ph√°t nh·∫°c n·ªÅn / √¢m thanh');
    if (agg.hasAsk) b.push('H·ªèi v√† nh·∫≠n c√¢u tr·∫£ l·ªùi t·ª´ ng∆∞·ªùi d√πng');
    if (b.length === 0) b.push('Kh√¥ng c√≥ logic ƒë√°ng k·ªÉ');
    return b.slice(0, 5);
  }

  // Initialization
  const flagScripts = scripts.filter(s => s.eventDesc.text.includes('c·ªù xanh'));
  if (flagScripts.length > 0) {
    const fp = flagScripts[0].chainPatterns;
    if (fp.setsPosition || fp.varsSet.size > 0 || fp.hasShow || fp.hasHide) b.push('Kh·ªüi t·∫°o tr·∫°ng th√°i khi b·∫Øt ƒë·∫ßu game');
  }

  // Key controls
  if (agg.hasKeyControls) {
    const keys = [...agg.keyNames];
    if (keys.length > 0) b.push(`ƒêi·ªÅu khi·ªÉn b·∫±ng ph√≠m: ${keys.slice(0, 5).join(', ')}`);
    else b.push('Ph·∫£n h·ªìi ph√≠m b·∫•m / chu·ªôt');
  }

  // Main loop behavior
  if (agg.hasForeverLoop) {
    const parts = [];
    if (agg.hasKeyControls && agg.hasMotion) parts.push('di chuy·ªÉn theo ph√≠m');
    else if (agg.hasMotion) parts.push('di chuy·ªÉn');
    if (agg.hasCollision) parts.push('ki·ªÉm tra va ch·∫°m');
    if (agg.hasCostumeChange) parts.push('ƒë·ªïi trang ph·ª•c');
    if (agg.hasCloning) parts.push('t·∫°o b·∫£n sao');
    if (parts.length > 0) b.push(`V√≤ng l·∫∑p ch√≠nh: ${parts.join(', ')}`);
  }

    // Clone behavior
  if (agg.hasCloneStart) {
    const cp = [];
    if (agg.hasMotion) cp.push('di chuy·ªÉn');
    if (agg.hasCollision) cp.push('ki·ªÉm tra va ch·∫°m');
    if (agg.deletesClone) cp.push('t·ª± x√≥a khi xong');
    b.push(`B·∫£n sao: ${cp.length > 0 ? cp.join(', ') : 'x·ª≠ l√Ω khi ƒë∆∞·ª£c t·∫°o'}`);
  }

  // Collision targets
  if (agg.collisionTargets.size > 0) {
    b.push(`Va ch·∫°m v·ªõi: ${[...agg.collisionTargets].join(', ')}`);
  }

  // Broadcasts
  if (agg.broadcastsSent.size > 0) {
    b.push(`G·ª≠i t√≠n hi·ªáu: ${[...agg.broadcastsSent].slice(0, 3).join(', ')}`);
  }
  if (agg.broadcastsReceived.size > 0) {
    b.push(`Ph·∫£n h·ªìi t√≠n hi·ªáu: ${[...agg.broadcastsReceived].slice(0, 3).join(', ')}`);
  }

  // Variable modifications
  const allModified = new Set([...agg.allVarsSet, ...agg.allVarsChanged]);
  if (allModified.size > 0) {
    const important = [...allModified].filter(v => /score|ƒëi·ªÉm|point|level|life|m·∫°ng|health|time|timer/i.test(v));
    if (important.length > 0) b.push(`Thay ƒë·ªïi bi·∫øn quan tr·ªçng: ${important.join(', ')}`);
  }

  // Interaction
  if (agg.hasAsk) b.push('H·ªèi v√† nh·∫≠n c√¢u tr·∫£ l·ªùi');
  if (agg.hasSay && !agg.hasAsk) b.push('Hi·ªÉn th·ªã h·ªôi tho·∫°i');
  if (agg.hasPen) b.push('V·∫Ω tr√™n m√†n h√¨nh');
  if (agg.hasSound) b.push('Ph√°t √¢m thanh');

  if (b.length === 0) b.push('Kh√¥ng c√≥ logic ƒë√°ng k·ªÉ');
  return b.slice(0, 5);
}

// ========================================================================
// TLDR GENERATION
// ========================================================================
function generateTLDR(sprites, projectType, gp, vars) {
  const lines = [];
  lines.push(`<strong>Th·ªÉ lo·∫°i:</strong> ${projectType.desc}`);

  // Mechanisms
  const mechs = [];
  if (gp.keyHandlers > 0) mechs.push('ƒëi·ªÅu khi·ªÉn b·∫±ng ph√≠m');
  if (gp.cloneBlocks > 0) mechs.push('c∆° ch·∫ø clone');
  if (gp.collisionChecks > 0) mechs.push('ph√°t hi·ªán va ch·∫°m');
  if (gp.penBlocks > 0) mechs.push('v·∫Ω b·∫±ng b√∫t');
  if (gp.askBlocks > 0) mechs.push('h·ªèi ƒë√°p');
  if (gp.backdropSwitches > 0) mechs.push('chuy·ªÉn c·∫£nh');
  if (mechs.length > 0) lines.push(`<strong>C∆° ch·∫ø ch√≠nh:</strong> ${mechs.join(', ')}`);

  // Characters
  const nonStage = sprites.filter(s => !s.isStage);
  const player = nonStage.find(s => s.role.role === 'player');
  const enemies = nonStage.filter(s => s.role.role === 'enemy');
  if (player) lines.push(`<strong>Nh√¢n v·∫≠t ch√≠nh:</strong> "${player.name}" ‚Äî ${player.role.desc}`);
  if (enemies.length > 0) lines.push(`<strong>ƒê·ªëi th·ªß:</strong> ${enemies.map(e => '"' + e.name + '"').join(', ')}`);

  // Important variables
  const scoreVars = vars.filter(v => /score|ƒëi·ªÉm|point|level|life|m·∫°ng|health|time/i.test(v.name));
  if (scoreVars.length > 0) lines.push(`<strong>Bi·∫øn quan tr·ªçng:</strong> ${scoreVars.map(v => v.name + ' = ' + v.value).join(', ')}`);

  // Scale
  lines.push(`<strong>Quy m√¥:</strong> ${nonStage.length} sprite, ${gp.blockCount} block, ${gp.varCount} bi·∫øn, ${gp.listCount} danh s√°ch`);

  // Game flow
  const genres = ['arcade', 'platformer', 'game', 'clicker'];
  if (genres.includes(projectType.genre)) {
    lines.push(`<strong>Lu·ªìng ch∆°i:</strong> Kh·ªüi t·∫°o ‚Üí V√≤ng l·∫∑p game (ƒëi·ªÅu khi·ªÉn + ki·ªÉm tra va ch·∫°m) ‚Üí C·∫≠p nh·∫≠t ƒëi·ªÉm/tr·∫°ng th√°i`);
  } else if (projectType.genre === 'story') {
    lines.push(`<strong>Lu·ªìng:</strong> B·∫Øt ƒë·∫ßu ‚Üí H·ªôi tho·∫°i/Chuy·ªÉn c·∫£nh ‚Üí K·∫øt th√∫c`);
  } else if (projectType.genre === 'quiz') {
    lines.push(`<strong>Lu·ªìng:</strong> H·ªèi c√¢u h·ªèi ‚Üí Ki·ªÉm tra ƒë√°p √°n ‚Üí T√≠nh ƒëi·ªÉm`);
  }

  return lines;
}

// ========================================================================
// GAME FLOW GENERATION
// ========================================================================
function generateGameFlow(sprites, sent, received) {
  const steps = [];

  // Find green flag initialization
  const flagSprites = sprites.filter(s => s.scripts.some(sc => sc.eventDesc.text.includes('c·ªù xanh')));
  if (flagSprites.length > 0) {
    const inits = [];
    for (const sp of flagSprites) {
      const fs = sp.scripts.filter(sc => sc.eventDesc.text.includes('c·ªù xanh'));
      for (const f of fs) {
        if (f.chainPatterns.setsPosition || f.chainPatterns.varsSet.size > 0) inits.push(sp.name);
        if (f.chainPatterns.hasForeverLoop) steps.push(`"${sp.name}" b·∫Øt ƒë·∫ßu v√≤ng l·∫∑p ch√≠nh`);
      }
    }
    if (inits.length > 0) steps.unshift(`Kh·ªüi t·∫°o: ${[...new Set(inits)].join(', ')}`);
  }

  // Broadcast flow
  if (sent.size > 0) {
    const flows = [];
    for (const msg of sent) {
      const senders = sprites.filter(s => s.agg.broadcastsSent.has(msg)).map(s => s.name);
      const receivers = sprites.filter(s => s.agg.broadcastsReceived.has(msg)).map(s => s.name);
      if (senders.length > 0 && receivers.length > 0) {
        flows.push(`"${msg}": ${senders.join('/')} ‚Üí ${receivers.join('/')}`);
      }
    }
    if (flows.length > 0) steps.push(`T√≠n hi·ªáu: ${flows.slice(0, 5).join('; ')}`);
  }

  return steps;
}

// ========================================================================
// WARNING ENGINE ‚Äî 3 severity levels
// ========================================================================
function generateWarnings(sprites, sent, received, varMods, gp) {
  const warnings = [];

  // üî¥ Red: Dangerous bugs
  // broadcastAndWait to non-existent receiver
  for (const sp of sprites) {
    for (const sc of sp.scripts) {
      for (const msg of sc.chainPatterns.broadcastsSent) {
        // Check if it's a broadcastAndWait ‚Äî we'll flag all unmatched for now
      }
    }
  }

  // Variable race conditions on scoring variables
  for (const varName in varMods) {
    const mods = varMods[varName];
    if (mods.length <= 1) continue;
    const sprites_list = [...new Set(mods.map(m => m.sprite))];
    const isScoreVar = /score|ƒëi·ªÉm|point|level|life|m·∫°ng|health|time/i.test(varName);
    if (sprites_list.length > 1 && isScoreVar) {
      warnings.push({
        severity: 'red',
        category: 'variable-conflict',
        text: `Bi·∫øn "${varName}" (bi·∫øn quan tr·ªçng) b·ªã thay ƒë·ªïi b·ªüi ${sprites_list.length} sprite kh√°c nhau (${sprites_list.join(', ')}). Khi ch·∫°y song song, gi√° tr·ªã c√≥ th·ªÉ b·ªã sai.`,
        detail: `C√°c ngu·ªìn: ${mods.map(m => m.sprite + ' @ ' + m.event).join('; ')}`
      });
    }
  }

  // Forever loop without wait (performance)
  for (const sp of sprites) {
    for (const sc of sp.scripts) {
      if (sc.chainPatterns.hasForeverLoop && !sc.chainPatterns.foreverHasWait && !sc.chainPatterns.hasWait) {
        // Check if there's truly no delay mechanism
        const cp = sc.chainPatterns;
        if (!cp.hasSay && !cp.hasGlide && !cp.hasAsk && !cp.hasSound) {
          warnings.push({
            severity: 'red',
            category: 'performance',
            text: `"${sp.name}": V√≤ng l·∫∑p v√¥ h·∫°n kh√¥ng c√≥ block ƒë·ª£i/ch·ªù b√™n trong. C√≥ th·ªÉ g√¢y lag ho·∫∑c ƒë∆° tr√¨nh duy·ªát.`,
          });
        }
      }
    }
  }

    // üü° Yellow: Should check
  // Unmatched broadcasts
  const unmatchedSent = [...sent].filter(m => !received.has(m));
  const unmatchedReceived = [...received].filter(m => !sent.has(m));

  if (unmatchedSent.length > 0) {
    if (unmatchedSent.length <= 3) {
      for (const msg of unmatchedSent) {
        warnings.push({ severity: 'yellow', category: 'broadcast', text: `Broadcast "${msg}" ƒë∆∞·ª£c g·ª≠i nh∆∞ng kh√¥ng sprite n√†o nh·∫≠n. Tin nh·∫Øn b·ªã "l·∫°c".` });
      }
    } else {
      warnings.push({ severity: 'yellow', category: 'broadcast', text: `C√≥ ${unmatchedSent.length} tin nh·∫Øn ƒë∆∞·ª£c g·ª≠i nh∆∞ng kh√¥ng c√≥ b√™n nh·∫≠n.` });
    }
  }

  if (unmatchedReceived.length > 0) {
    for (const msg of unmatchedReceived) {
      // Ignore some standard ones if needed, but generally show
      warnings.push({ severity: 'yellow', category: 'broadcast', text: `S·ª± ki·ªán "${msg}" ƒë∆∞·ª£c ch·ªù ƒë·ª£i nh∆∞ng kh√¥ng bao gi·ªù ƒë∆∞·ª£c g·ª≠i.` });
    }
  }

  // Large script check
  for (const s of sprites) {
    for (const sc of s.scripts) {
      if (sc.blockCount > 35) {
        warnings.push({ severity: 'yellow', category: 'logic', text: `Sprite "${s.name}" c√≥ m·ªôt k·ªãch b·∫£n qu√° d√†i (${sc.blockCount} kh·ªëi). N√™n t√°ch nh·ªè ƒë·ªÉ d·ªÖ qu·∫£n l√Ω.` });
      }
    }
    // High block count total
    if (s.blockCount > 150) {
      warnings.push({ severity: 'yellow', category: 'performance', text: `Sprite "${s.name}" qu√° ph·ª©c t·∫°p (${s.blockCount} kh·ªëi). C√≥ th·ªÉ g√¢y lag tr√™n m√°y y·∫øu.` });
    }
  }

  // Empty loops
  for (const s of sprites) {
    for (const sc of s.scripts) {
      if (sc.hasForeverLoop && sc.blockCount < 3) {
        warnings.push({ severity: 'yellow', category: 'logic', text: `V√≤ng l·∫∑p "m√£i m√£i" trong "${s.name}" c√≥ v·∫ª tr·ªëng ho·∫∑c qu√° √≠t l·ªánh. C√≥ th·ªÉ g√¢y treo tr√¨nh duy·ªát.` });
      }
    }
  }

  return warnings;
}

function generateRecommendations(analysis) {
  const recs = [];
  const hasMultipleFlags = sprites.reduce((acc, s) => acc + s.scripts.filter(sc => sc.event === 'event_whenflagclicked').length, 0);

  if (hasMultipleFlags > 8) {
    recs.push({ category: 'structure', text: "D·ª± √°n d√πng r·∫•t nhi·ªÅu kh·ªëi 'Khi nh·∫•n C·ªù xanh'. H√£y th·ª≠ d√πng Broadcast ƒë·ªÉ ƒëi·ªÅu khi·ªÉn th·ª© t·ª± b·∫Øt ƒë·∫ßu ch√≠nh x√°c h∆°n." });
  }

  const hasVariables = sprites.some(s => s.variables.length > 0) || analysis.stage.variables.length > 0;
  if (!hasVariables) {
    recs.push({ category: 'logic', text: "D·ª± √°n hi·ªán ch∆∞a d√πng Bi·∫øn s·ªë. H√£y th·ª≠ d√πng bi·∫øn ƒë·ªÉ l∆∞u ƒëi·ªÉm s·ªë ho·∫∑c tr·∫°ng th√°i tr√≤ ch∆°i." });
  }

  const complexSprites = sprites.filter(s => s.blockCount > 100);
  if (complexSprites.length > 0) {
    recs.push({ category: 'organization', text: "M·ªôt s·ªë nh√¢n v·∫≠t c√≥ r·∫•t nhi·ªÅu code. B·∫°n c√≥ th·ªÉ d√πng 'Kh·ªëi c·ªßa t√¥i' (My Blocks) ƒë·ªÉ gom c√°c nh√≥m l·ªánh l·∫°i cho g·ªçn." });
  }

  // Sound check
  const hasSound = sprites.some(s => s.sounds.length > 0);
  if (!hasSound) {
    recs.push({ category: 'polish', text: "Th√™m √¢m thanh ho·∫∑c nh·∫°c n·ªÅn s·∫Ω l√†m d·ª± √°n c·ªßa b·∫°n sinh ƒë·ªông h∆°n r·∫•t nhi·ªÅu!" });
  }

  // Comments check
  // Note: Scratch project.json stores comments separately, usually not analyzed here for simplicity

  return recs;
}

// ========================================================================
// RENDERING
// ========================================================================
function populateSpriteFocus() {
  const sel = document.getElementById('spriteFocus');
  sel.innerHTML = '<option value="">üìã T·∫•t c·∫£ nh√¢n v·∫≠t</option>';

  // Stage first
  const optStage = document.createElement('option');
  optStage.value = '_stage_';
  optStage.textContent = 'üñºÔ∏è Ph√¥ng n·ªÅn (Stage)';
  sel.appendChild(optStage);

  globalAnalysisData.sprites.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s.name;
    opt.textContent = `üëæ ${s.name}`;
    sel.appendChild(opt);
  });
}

function switchLevel(lvl) {
  currentLevel = lvl;
  document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active', 'bg-blue-50', 'text-blue-700'));
  const btn = document.getElementById('lvl' + lvl);
  btn.classList.add('active', 'bg-blue-50', 'text-blue-700');

  const desc = document.getElementById('levelDesc');
  if (lvl === 1) desc.textContent = "üìä Ch·ªâ hi·ªÉn th·ªã t√≥m t·∫Øt vai tr√≤ v√† ch·ª©c nƒÉng ch√≠nh c·ªßa t·ª´ng nh√¢n v·∫≠t.";
  if (lvl === 2) desc.textContent = "üìä Hi·ªÉn th·ªã logic ch√≠nh, c·∫£nh b√°o th·ª±c t·∫ø, v√† g·ª£i √Ω c·∫£i thi·ªán.";
  if (lvl === 3) desc.textContent = "üìä Hi·ªÉn th·ªã chi ti·∫øt t·ª´ng b∆∞·ªõc th·ª±c hi·ªán c·ªßa t·∫•t c·∫£ c√°c k·ªãch b·∫£n.";

  renderResults();
}

function applyFocus() {
  currentFocus = document.getElementById('spriteFocus').value;
  renderResults();
}

function showDebugOnly() {
  debugOnlyMode = true;
  showDebugPanel = true;
  renderResults();
}

function showRecsOnly() {
  // Simple filter logic via render
  renderResults(true); 
}

function adjustLevel(dir) {
  if (dir === 'more' && currentLevel < 3) switchLevel(currentLevel + 1);
  if (dir === 'less' && currentLevel > 1) switchLevel(currentLevel - 1);
}

function renderResults(recsOnly = false) {
  if (!globalAnalysisData) return;
  const container = document.getElementById('resultsContent');
  container.innerHTML = '';

  const data = globalAnalysisData;

  // 1. Overview Header
  const header = document.createElement('div');
  header.className = 'bg-white rounded-xl border p-5 shadow-sm';
  header.innerHTML = `
    <div class="flex justify-between items-start">
      <div>
        <h2 class="text-xl font-bold text-gray-800">D·ª± √°n: ${esc(data.projectName)}</h2>
        <p class="text-gray-500 text-sm">T·ªïng c·ªông ${data.sprites.length} nh√¢n v·∫≠t v√† ${data.stage.scripts.length + data.sprites.reduce((a,s)=>a+s.scripts.length,0)} k·ªãch b·∫£n.</p>
      </div>
      <div class="text-right no-print">
        <span class="text-xs font-mono text-gray-400">v1.2 Stable</span>
      </div>
    </div>
  `;
  container.appendChild(header);

  // 2. Debug/Warnings Panel
  if (showDebugPanel && data.warnings.length > 0 && !recsOnly) {
    const debugWrap = document.createElement('div');
    debugWrap.className = 'bg-white rounded-xl border overflow-hidden shadow-sm';
    debugWrap.innerHTML = `
      <div class="bg-orange-50 px-4 py-2 border-b border-orange-100 flex justify-between items-center">
        <h3 class="font-bold text-orange-800 text-sm flex items-center gap-2">‚ö†Ô∏è Ph√°t hi·ªán ${data.warnings.length} v·∫•n ƒë·ªÅ c·∫ßn l∆∞u √Ω</h3>
        <button onclick="togglePanel('debug')" class="text-xs text-orange-600 hover:underline cursor-pointer">·∫®n b·∫£ng</button>
      </div>
      <div class="p-2 space-y-1">
        ${data.warnings.map(w => `
          <div class="px-3 py-2 rounded-lg text-sm severity-${w.severity} flex gap-3">
            <span>${w.severity === 'red' ? '‚ùå' : '‚ö†Ô∏è'}</span>
            <div>
              <span class="font-bold uppercase text-[10px] opacity-60">${w.category}</span>
              <p class="text-gray-800">${esc(w.text)}</p>
            </div>
          </div>
        `).join('')}
      </div>
    `;
    container.appendChild(debugWrap);
  }

  // 3. Recommendations
  if (data.recommendations.length > 0) {
    const recWrap = document.createElement('div');
    recWrap.className = 'bg-white rounded-xl border overflow-hidden shadow-sm';
    recWrap.innerHTML = `
      <div class="bg-green-50 px-4 py-2 border-b border-green-100 flex justify-between items-center">
        <h3 class="font-bold text-green-800 text-sm flex items-center gap-2">üí° G·ª£i √Ω c·∫£i thi·ªán</h3>
      </div>
      <div class="p-4 grid grid-cols-1 md:grid-cols-2 gap-3">
        ${data.recommendations.map(r => `
          <div class="flex gap-3 items-start p-3 bg-gray-50 rounded-lg border border-gray-100">
            <span class="text-xl">‚ú®</span>
            <p class="text-sm text-gray-700">${esc(r.text)}</p>
          </div>
        `).join('')}
      </div>
    `;
    container.appendChild(recWrap);
    if (recsOnly) return; 
  }

  // 4. Sprites Analysis
  const spritesToRender = [];
  if (!currentFocus || currentFocus === '_stage_') spritesToRender.push({ isStage: true, ...data.stage });
  data.sprites.forEach(s => {
    if (!currentFocus || currentFocus === s.name) spritesToRender.push({ isStage: false, ...s });
  });

  spritesToRender.forEach(s => {
    const card = document.createElement('div');
    card.className = 'bg-white rounded-xl border shadow-sm overflow-hidden';

    // Role logic
    const roleHtml = s.roles && showRolesPanel ? `
      <div class="flex flex-wrap gap-1 mt-2">
        ${s.roles.map(r => `<span class="role-badge role-${r.id}">${r.label}</span>`).join('')}
      </div>
    ` : '';

    const behaviorHtml = s.behaviors && currentLevel >= 2 ? `
      <div class="mt-3 flex flex-wrap items-center">
        <span class="text-[10px] font-bold text-gray-400 uppercase mr-2">H√†nh vi:</span>
        ${s.behaviors.map(b => `<span class="behavior-chip">${esc(b)}</span>`).join('')}
      </div>
    ` : '';

    card.innerHTML = `
      <div class="p-5 ${s.isStage ? 'bg-slate-50' : ''}">
        <div class="flex justify-between items-start">
          <div>
            <h3 class="text-lg font-bold text-gray-800">${s.isStage ? 'üñºÔ∏è Ph√¥ng n·ªÅn (Stage)' : 'üëæ Nh√¢n v·∫≠t: ' + esc(s.name)}</h3>
            ${roleHtml}
          </div>
          <div class="text-right">
            <div class="text-xs text-gray-400 font-mono">${s.scripts.length} k·ªãch b·∫£n | ${s.blockCount} kh·ªëi</div>
          </div>
        </div>
        
        ${behaviorHtml}

        <div class="mt-4 space-y-4">
          ${s.scripts.map((sc, idx) => renderScript(sc, s.blocks, idx)).join('')}
        </div>
      </div>
    `;
    container.appendChild(card);
  });
}

function renderScript(sc, blocks, index) {
  const ev = getEventDescription(blocks[sc.id], blocks);

  // Level 1: Tiny summary
  if (currentLevel === 1) {
    return `
      <div class="border rounded-lg p-3 bg-gray-50 flex items-center justify-between">
        <div class="flex items-center gap-3">
          <span class="event-badge ${ev.cls} mb-0">${ev.text}</span>
          <span class="text-sm text-gray-600">${sc.summary}</span>
        </div>
        <span class="text-[10px] text-gray-400 font-mono">${sc.blockCount} kh·ªëi</span>
      </div>
    `;
  }

  // Level 2 & 3: Detailed
  const content = currentLevel === 3 
    ? `<div class="mt-2 text-sm text-gray-700 bg-white p-3 rounded border border-gray-100 font-mono leading-relaxed">${followChain(blocks[sc.id].next, blocks, '', 0)}</div>`
    : `<div class="mt-2 text-sm text-gray-600 pl-2 border-l-2 border-gray-100">${sc.summary}</div>`;

  return `
    <div class="group">
      <div class="flex items-center gap-2">
        <span class="event-badge ${ev.cls}">${ev.text}</span>
        <span class="text-[10px] text-gray-300 font-mono opacity-0 group-hover:opacity-100 transition-opacity">#${index+1}</span>
      </div>
      ${content}
    </div>
  `;
}

function copyResults() {
  const el = document.getElementById('resultsContent');
  // Simple text extraction
  const text = el.innerText;
  navigator.clipboard.writeText(text).then(() => {
    showToast('ƒê√£ copy k·∫øt qu·∫£!');
  }).catch(() => {
    // Fallback
    const ta = document.createElement('textarea');
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    showToast('ƒê√£ copy k·∫øt qu·∫£!');
  });
}

function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.style.opacity = '1';
  setTimeout(() => { toast.style.opacity = '0'; }, 2000);
}

function togglePanel(panel) {
  if (panel === 'roles') {
    showRolesPanel = !showRolesPanel;
    const btn = document.getElementById('btnToggleRoles');
    if (showRolesPanel) {
      btn.innerHTML = 'üëÅÔ∏è Vai tr√≤';
      btn.className = 'px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-green-50 text-green-700 border-green-200 hover:bg-green-100';
    } else {
      btn.innerHTML = 'üö´ Vai tr√≤';
      btn.className = 'px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-gray-100 text-gray-400 border-gray-200';
    }
  } else if (panel === 'debug') {
    showDebugPanel = !showDebugPanel;
    const btn = document.getElementById('btnToggleDebug');
    if (showDebugPanel) {
      btn.innerHTML = 'üëÅÔ∏è C·∫£nh b√°o';
      btn.className = 'px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-orange-50 text-orange-700 border-orange-200 hover:bg-orange-100';
    } else {
      btn.innerHTML = 'üö´ C·∫£nh b√°o';
      btn.className = 'px-3 py-1.5 rounded-lg text-sm font-medium border cursor-pointer bg-gray-100 text-gray-400 border-gray-200';
    }
  }
  renderResults();
}

</script>
</body>
</html>
